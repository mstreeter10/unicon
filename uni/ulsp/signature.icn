package ulsp

import json

class SignatureHandler(
   workspace,
   params
   )

   method setVariables(new_workspace, new_params)
      workspace := new_workspace
      params := new_params
   end

   method run()
      local line, character, functionName, results_table, activeParam

      # Collect line and character position #
      line := params["position"]["line"]
      character := params["position"]["character"]

      # Create initial return table #
      results_table := table()
      results_table["signatures"] := []

      # Collect context information (inside comment, space before, object before, no object before) #
      _context := getContext(line, character, workspace.temp_file)
      \_context | return createResults(results_table)

      case _context of {

         # If object before, collect object information #
         "object before" : {

            functionName := getFunction(line, character, workspace.temp_file)
            objectName := getObject(line, character, workspace.temp_file)

            linked_classes := workspace.getLinkedClasses()
            imported_classes := workspace.getImportedClasses()
            internal_classes := workspace.getInternalClasses()

            objects := workspace.getObjects()
            className := objects[objectName]

            # Check if function is a method of a linked class #
            if member(linked_classes, className) & member(linked_classes[className]["methods"], functionName) then {
               updateResults(functionName, linked_classes[className]["methods"][functionName], results_table)
            } 

            # Check if function is a method of an imported class #
            else if member(imported_classes, className) & member(imported_classes[className]["methods"], functionName) then {
               updateResults(functionName, imported_classes[className]["methods"][functionName], results_table)
            }

            # Check if function is a method of an internal class #
            else if member(internal_classes, className) & member(internal_classes[className]["methods"], functionName) then {
               updateResults(functionName, internal_classes[className]["methods"][functionName], results_table)
            }
         } 

         # If no object before, treat as method inside class, procedures, or built-in-funtion (eventually) #
         "no object before" : { 

            functionName := getFunction(line, character, workspace.temp_file)

            internal_classes := workspace.getInternalClasses()
            linked_procedures := workspace.getLinkedProcedures()
            imported_procedures := workspace.getImportedProcedures()
            internal_procedures := workspace.getInternalProcedures()

            # Check if function is part of an internal class #
            every className := key(internal_classes) do {
               if member(internal_classes[className]["methods"], functionName) then {
                  updateResults(functionName, internal_classes[className]["methods"][functionName], results_table)
               }
            }
            
            # Check if function is a linked procedure #
            if member(linked_procedures, functionName) then {
               updateResults(functionName, linked_procedures[functionName], results_table)
            }

            # Check if function is an imported procedure #
            if member(imported_procedures, functionName) then {
               updateResults(functionName, imported_procedures[functionName], results_table)
            }

            # Check if function is an internal procedure #
            if member(internal_procedures, functionName) then {
               updateResults(functionName, internal_procedures[functionName], results_table)
            }
         }
      }

      activeParam := 0

      # Finding active parameter (if there is one) #
      write(ximage(params))
      if params["context"]["isRetrigger"] == "__true__" & \params["context"]["activeSignatureHelp"] then {
         current_sig := params["context"]["activeSignatureHelp"]["signatures"][1]["label"]
         activeParam := getActiveParameter(line, character, workspace.temp_file, current_sig)
         results_table["signatures"][1]["activeParameter"] := activeParam
      }
      
      # (>^-^)> *hug*

      # Convert and return finished table #
      return createResults(results_table)
   end

   method createResults(results_table)
      results := tojson(results_table)
      return results
   end

   # Finding the active parameter #
   method getActiveParameter(line, character, file, current_sig)
      local sig_function, desired_line, param_num

      param_num := 0

      desired_line := getDesiredLine(line, file)

      current_sig ? {
         sig_function := tab(upto("("))
      }

      desired_line ? {
         &pos := character
         repeat { 
            if desired_line[&pos] == "," then param_num +:= 1
            if desired_line[&pos] == "(" then {
               initial_pos := &pos
               
               until desired_line[&pos - 1] == " " | desired_line[&pos - 1] == "."  | &pos = 1 do {
                  move(-1)
               }

               if tab(initial_pos) == sig_function then break
            }
            if &pos = 1 then break
            move(-1)
         }
      }

      write(desired_line)
      write(param_num)

      return param_num
   end

   # Update the results table #
   method updateResults(function, functionTable, results_table)
      local signature

      # Create a valid signature #
      signature := createSignature(function, functionTable)

      # Put method params in result table #
      put(results_table["signatures"], table("label", signature, "parameters", [], "documentation", functionTable["comments"]))
      every param_table := !functionTable["params"] do 
         put(results_table["signatures"][1]["parameters"], table("label", param_table["name"]))
   end

   # Create a valid signature #
   method createSignature(function, functionTable)
      local signature, counter

      counter := 0
      signature := function || "("

      every param_table := !functionTable["params"] do {
         signature ||:= param_table["name"]
         if \param_table["type"] then signature ||:= ":" || param_table["type"]
         if \param_table["default"] then signature ||:= ":" || param_table["default"]
         counter +:= 1
         if counter < *functionTable["params"] then signature ||:= ", "   
         write(functionTable["comments"])
      }

      signature ||:= ")"
 
      

      return signature
   end

   # Retriving context #
   method getContext(line, character, file)
      desired_line := getDesiredLine(line, file)

      \desired_line | fail

      desired_line ? {
         while (&pos < character) do {
            ch := move(1) | break
            if ch == "#" then 
               return "inside comment"
            }
         }

      desired_line ? {
         &pos := character
         if move(-1) == " " then 
            return "space before"
         }
      
      desired_line ? {
         &pos := character
         until desired_line[&pos] == " " | desired_line[&pos] == "." | &pos = 1 do {
            move(-1)
         }
         if desired_line[&pos] == "." & desired_line[&pos -1] ~== " " then 
            return "object before"
      }
      return "no object before"
   end

   # Retriving function name #
   method getFunction(line, character, file)
      desired_line := getDesiredLine(line, file)

      desired_line ? {
         &pos := character

         until desired_line[&pos] == " " | desired_line[&pos] == "."  | &pos = 1 do {
            move(-1)
         }
         if desired_line[&pos] == " " | desired_line[&pos] == "." then move(1)

         _function := tab(upto("("))

         return _function
      }
   end

   # Retriving object name #
   method getObject(line, character, file)
      desired_line := getDesiredLine(line, file)

      desired_line ? {
         &pos := character

         until desired_line[&pos] == " " | &pos = 1 do {
            move(-1)
         }
         if desired_line[&pos] == " " then move(1)

         return tab(upto("."))
      }
   end

   # Returning line from temp file as string #
   method getDesiredLine(line, file)
      f := open(file)
      every !line do read(f)
      desired_line := read(f)
      return desired_line
   end
end