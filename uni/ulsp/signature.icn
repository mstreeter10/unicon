package ulsp

import json

class SignatureHandler(
   workspace,
   params
   )

   method setVariables(new_workspace, new_params)
      workspace := new_workspace
      params := new_params
   end

   method run()
      local line, character, functionName, results_table

      # Collect line and character position #
      line := params["position"]["line"]
      character := params["position"]["character"]


      # Collect context information (inside comment, space before, object before, no object before) #
      _context := getContext(line, character, workspace.temp_file)
      \_context | fail

      # Create initial return table #
      results_table := table()
      results_table["signatures"] := []

      case _context of {

         # If object before, collect object information #
         "object before" : {

            functionName := getFunction(line, character, workspace.temp_file)
            objectName := getObject(line, character, workspace.temp_file)

            linked_classes := workspace.getLinkedClasses()
            imported_classes := workspace.getImportedClasses()
            internal_classes := workspace.getInternalClasses()

            objects := workspace.getObjects()
            className := objects[objectName]

            # Check if function is a method of a linked class #
            if member(linked_classes, className) & member(linked_classes[className]["methods"], functionName) then {
               updateResults(functionName, linked_classes[className]["methods"][functionName], results_table)
            } 

            # Check if function is a method of an imported class #
            else if member(imported_classes, className) & member(imported_classes[className]["methods"], functionName) then {
               updateResults(functionName, imported_classes[className]["methods"][functionName], results_table)
            }

            # Check if function is a method of an internal class #
            else if member(internal_classes, className) & member(internal_classes[className]["methods"], functionName) then {
               updateResults(functionName, internal_classes[className]["methods"][functionName], results_table)
            }
         } 

         # If no object before, treat as method inside class, procedures, or built-in-funtion (eventually) #
         "no object before" : { 

            functionName := getFunction(line, character, workspace.temp_file)

            internal_classes := workspace.getInternalClasses()
            linked_procedures := workspace.getLinkedProcedures()
            imported_procedures := workspace.getImportedProcedures()
            internal_procedures := workspace.getInternalProcedures()

            # Check if function is part of an internal class #
            every className := key(internal_classes) do {
               if member(internal_classes[className]["methods"], functionName) then {
                  updateResults(functionName, internal_classes[className]["methods"][functionName], results_table)
               }
            }
            
            # Check if function is a linked procedure #
            if member(linked_procedures, functionName) then {
               updateResults(functionName, linked_procedures[functionName], results_table)
            }

            # Check if function is an imported procedure #
            if member(imported_procedures, functionName) then {
               updateResults(functionName, imported_procedures[functionName], results_table)
            }

            # Check if function is an internal procedure #
            if member(internal_procedures, functionName) then {
               updateResults(functionName, internal_procedures[functionName], results_table)
            }
         }
      }

      # Convert and return finished table #
      results := tojson(results_table)
      return results
   end

   # Update the results table #
   method updateResults(function, functionTable, results_table)
      local signature
      
      # Create a valid signature #
      signature := createSignature(function, functionTable)

      # Put method params in result table #
      put(results_table["signatures"], table("label", signature, "parameters", []))
      every paramName := key(functionTable["params"]) do 
         put(results_table["signatures"][1]["parameters"], table("label", paramName))
   end

   # Create a valid signature #
   method createSignature(function, functionTable)
      local signature, counter

      counter := 0
      signature := function || "("

      every paramName := key(functionTable["params"]) do {
         if member(functionTable["params"][paramName], "type") & member(functionTable["params"][paramName], "default") then {
            if counter < *functionTable["params"] - 1 then
               signature ||:= paramName || ":" || functionTable["params"][paramName]["type"] || ":" || functionTable["params"][paramName]["default"] || ", "
            else
               signature ||:= paramName || ":" || functionTable["params"][paramName]["type"] || ":" || functionTable["params"][paramName]["default"]
            }
         else if member(functionTable["params"][paramName], "type") then {
            if counter < *functionTable["params"] - 1 then
               signature ||:= paramName || ":" || functionTable["params"][paramName]["type"] || ", "
            else
               signature ||:= paramName || ":" || functionTable["params"][paramName]["type"]
            }
         else if member(functionTable["params"][paramName], "default") then {
            if counter < *functionTable["params"] - 1 then
               signature ||:= paramName || ":" || functionTable["params"][paramName]["default"] || ", "
            else
               signature ||:= paramName || ":" || functionTable["params"][paramName]["default"]
            }
         else {
            if counter < *functionTable["params"] - 1 then
               signature ||:= paramName || ", "
            else
               signature ||:= paramName
            }
         counter +:= 1
         }

      signature ||:= ")"

      return signature
   end

   # Retriving context #
   method getContext(line, character, file)
      desired_line := getDesiredLine(line, file)

      \desired_line | fail

      desired_line ? {
         while (&pos < character) do {
            ch := move(1)
            if ch == "#" then 
               return "inside comment"
            }
         }

      desired_line ? {
         &pos := character
         if move(-1) == " " then 
            return "space before"
         }
      
      desired_line ? {
         &pos := character
         until desired_line[&pos] == " " | desired_line[&pos] == "." | &pos = 1 do move(-1)
         if desired_line[&pos] == "." & desired_line[&pos -1] ~== " " then 
            return "object before"
      }
      return "no object before"
   end

   # Retriving method name #
   method getFunction(line, character, file)
      desired_line := getDesiredLine(line, file)

      desired_line ? {
         &pos := character

         until desired_line[&pos] == " " | desired_line[&pos] == "."  | &pos = 1 do move(-1)
         if desired_line[&pos] == " " | desired_line[&pos] == "." then move(1)

         return tab(upto("("))
      }
   end

   # Retriving object name #
   method getObject(line, character, file)
      desired_line := getDesiredLine(line, file)

      desired_line ? {
         &pos := character

         until desired_line[&pos] == " " | &pos = 1 do move(-1)
         if desired_line[&pos] == " " then move(1)

         return tab(upto("."))
      }
   end

   # Returning line from temp file as string #
   method getDesiredLine(line, file)
      f := open(file)
      every !line do read(f)
      desired_line := read(f)
      return desired_line
   end
end