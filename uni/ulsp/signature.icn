package ulsp

import json
global triggerCharLoc

class SignatureHandler(
   workspace,
   params
   )

   method setVariables(new_workspace, new_params)
      workspace := new_workspace
      params := new_params
   end

   method run()
      local line, character, functionName, results_table, activeParam

      # Collect line and character position #
      line := params["position"]["line"]
      character := params["position"]["character"]	

      # Create initial return table #
      results_table := table()
      results_table["signatures"] := []
      results_table["activeSignature"] := &null
      results_table["activeParameter"] := &null

      # Extract desired line #
      desired_line := getDesiredLine(line, workspace.temp_file)
      \desired_line | return createResults(results_table)

      # Handle an active signature #
      if \params["context"]["activeSignatureHelp"] then {
         handleActiveSignature(params, results_table, desired_line, character)
         return createResults(results_table)
      }

      # Handle a new signature #
      handleNewSignature(desired_line, character, results_table)
      
      # Convert and return finished table #
      return createResults(results_table)
   end

   # Handle a new signature #
   method handleNewSignature(desired_line, character, results_table)
   local _context

      # Collect context information (inside comment, space before, object before, no object before) #
      _context := getContext(desired_line, character)

      triggerCharLoc := character

      case _context of {

         # If object before, collect object information #
         "object before" : {

            functionName := getFunction(desired_line, character)
            objectName := getObject(desired_line, character)

            linked_classes := workspace.getLinkedClasses()
            imported_classes := workspace.getImportedClasses()
            internal_classes := workspace.getInternalClasses()

            objects := workspace.getObjects()
            className := objects[objectName]

            # Check if function is a method of a linked class #
            if member(linked_classes, className) & member(linked_classes[className]["methods"], functionName) then {
               updateResults(functionName, linked_classes[className]["methods"][functionName], results_table)
            } 

            # Check if function is a method of an imported class #
            if member(imported_classes, className) & member(imported_classes[className]["methods"], functionName) then {
               updateResults(functionName, imported_classes[className]["methods"][functionName], results_table)
            }

            # Check if function is a method of an internal class #
            if member(internal_classes, className) & member(internal_classes[className]["methods"], functionName) then {
               updateResults(functionName, internal_classes[className]["methods"][functionName], results_table)
            }
         } 

         # If no object before, treat as method inside class, procedures, or built-in-funtion (eventually) #
         "no object before" : { 

            functionName := getFunction(desired_line, character)

            built_in_functions := workspace.getBuiltInFunctions()
            internal_classes := workspace.getInternalClasses()
            linked_procedures := workspace.getLinkedProcedures()
            imported_procedures := workspace.getImportedProcedures()
            internal_procedures := workspace.getInternalProcedures()

            # Check if function is a built in function #
            if member(built_in_functions, functionName) then {
               updateResults(functionName, built_in_functions[functionName], results_table)
            }

            # Check if function is part of an internal class #
            every className := key(internal_classes) do {
               if member(internal_classes[className]["methods"], functionName) then {
                  updateResults(functionName, internal_classes[className]["methods"][functionName], results_table)
               }
            }
            
            # Check if function is a linked procedure #
            if member(linked_procedures, functionName) then {
               updateResults(functionName, linked_procedures[functionName], results_table)
            }

            # Check if function is an imported procedure #
            if member(imported_procedures, functionName) then {
               updateResults(functionName, imported_procedures[functionName], results_table)
            }

            # Check if function is an internal procedure #
            if member(internal_procedures, functionName) then {
               updateResults(functionName, internal_procedures[functionName], results_table)
            }
         }
      }
   end

   # Handle an active signature #
   method handleActiveSignature(params, results_table, line, character)
   local activeParam := 0, depth := 0, current_sig, current_params

      if /triggerCharLoc | (character < triggerCharLoc) then {
         triggerCharLoc := &null
         fail
      }

      line ? {
         &pos := triggerCharLoc
         until &pos = character do {
            move(1)
            if line[&pos] == "(" then
               depth +:= 1
            else if line[&pos] == ")" then 
               depth -:= 1
            else if line[&pos] == "," & depth = 0 then 
               activeParam +:= 1
         }
      }

      if depth < 0 then {
         triggerCharLoc := &null
         fail
      }

      results_table["signatures"] := params["context"]["activeSignatureHelp"]["signatures"]
      results_table["activeSignature"] := params["context"]["activeSignatureHelp"]["activeSignature"]
      results_table["activeParameter"] := activeParam
   end

   # Convert results to json #
   method createResults(results_table)
      results := tojson(results_table)
      return results
   end

   # Update the results table #
   method updateResults(function, functionTable, results_table)
      local signature, param_list := []

      # Create a valid signature #
      signature := createSignature(function, functionTable)

      # Format parameters #
      every param_table := !functionTable["params"] do 
         put(param_list, table("label", param_table["name"]))

      # Update results #
      put(results_table["signatures"], table("label", signature, "parameters", param_list))
   end

   # Create a valid signature #
   method createSignature(function, functionTable)
      local signature, counter

      counter := 0
      signature := function || "("

      every param_table := !functionTable["params"] do {
         signature ||:= param_table["name"]
         if \param_table["type"] then signature ||:= ":" || param_table["type"]
         if \param_table["default"] then signature ||:= ":" || param_table["default"]
         counter +:= 1
         if counter < *functionTable["params"] then signature ||:= ", "   
      }

      signature ||:= ")"

      return signature
   end

   # Retrive context #
   method getContext(line, character)

      line ? {
         while (&pos < character) do {
            ch := move(1) | break
            if ch == "#" then 
               return "inside comment"
            }
         }

      line ? {
         &pos := character
         if move(-1) == " " then 
            return "space before"
         }
      
      line ? {
         if objectName := getObject(line, character) then 
            return "object before"  
      }
      return "no object before"
   end

   # Retrive function name #
   method getFunction(line, character)
      identifiers := &letters ++ &digits ++ '_' ++ '-'

      line ? {
         temp := tab(character)
         while c := move(-1) do {
            if (c ** identifiers) ~== c then { 
               break
            }
         }

         if &pos ~= 1 then move(1)

         _function := tab(upto("("))
         return _function
      }
   end

   # Retrive object name #
   method getObject(line, character)
      identifiers := &letters ++ &digits ++ '_' ++ '-'

      line ? {
         temp := tab(character)
         while c := move(-1) do {
            if (c ** identifiers) ~== c then { 
               break
                  }
            }

         if ="." then {
            move(-1)
            while c := move(-1) do {
               if (c ** identifiers) ~== c then { 
                  move(1)
                  break
                     }
               }
            objectName := tab(upto("."))
            return objectName
            }
         }
   end

   # Return line from temp file as string #
   method getDesiredLine(line, file)
      f := open(file)
      every !line do read(f)
      desired_line := read(f)
      return desired_line
   end
end